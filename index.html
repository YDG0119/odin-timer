/* =========================
   V29 PATCH PACK (Drop-in)
   - add: applyZenCalc, btl, normalizeTimers
   - replace: switchProfile, pushUndo, executeUndo, setTimer, loop, renderSched, parseSmart
   ========================= */

/* [ADD] 저장된 타이머(구버전 포함) 형태 보정: lastD/m5/m1 누락 방지 */
function normalizeTimers() {
  const now = Date.now();
  st.timers = (st.timers || []).map(x => {
    const t = typeof x.t === 'number' ? x.t : Number(x.t);
    const d = Math.floor((t - now) / 1000);
    return {
      n: x.n,
      t,
      m5: !!x.m5,
      m1: !!x.m1,
      lastD: (typeof x.lastD === 'number') ? x.lastD : d
    };
  });
}

/* [REPLACE] 멀티 프로필 로직 (active 토글 범위 수정 + 타이머 normalize) */
function switchProfile(p) {
  st.profile = p;
  localStorage.setItem('v29_current_p', p);

  // ✅ 프로필 버튼만 active 처리 (Test/WakeLock 버튼 영향 제거)
  document.querySelectorAll('.p-btn[data-p]').forEach(b =>
    b.classList.toggle('active', b.dataset.p === p)
  );

  // timers 로드 (A는 v28 마이그레이션)
  const stored = localStorage.getItem(`v29_${p}_timers`);
  if (!stored && p === 'A') st.timers = JSON.parse(localStorage.getItem('v28_timers')) || [];
  else st.timers = JSON.parse(stored) || [];

  st.favs = JSON.parse(localStorage.getItem(`v29_${p}_favs`)) || [];
  st.recent = JSON.parse(localStorage.getItem(`v29_${p}_recent`)) || [];
  st.foldState = JSON.parse(localStorage.getItem(`v29_${p}_fold`)) || {};

  // ✅ 구버전/누락 필드 보정
  normalizeTimers();

  renderSched();
  renderFavs();
  syncTxt();
  addLog(`프로필 ${p} 전환됨`);
}

/* [REPLACE] Undo 로직 (timers + recent 함께 복구) */
function pushUndo(msg) {
  st.undoStack = {
    timers: JSON.parse(JSON.stringify(st.timers || [])),
    recent: JSON.parse(JSON.stringify(st.recent || []))
  };

  const toast = document.getElementById('undo-toast');
  document.getElementById('undo-msg').innerText = msg;
  toast.style.display = 'flex';

  if (st.undoT) clearTimeout(st.undoT);
  st.undoT = setTimeout(() => {
    toast.style.display = 'none';
    st.undoStack = null;
  }, 5000);
}

function executeUndo() {
  if (!st.undoStack) return;
  st.timers = st.undoStack.timers || [];
  st.recent = st.undoStack.recent || [];

  saveStore();
  renderSched();
  renderFavs();

  document.getElementById('undo-toast').style.display = 'none';
  addLog("명령 취소(Undo) 완료");
}

/* [ADD] Forced Sync 버튼 동작용 (누락 함수) */
function applyZenCalc() {
  const name = document.getElementById('zc-sel').value;
  const raw = (document.getElementById('zc-in').value || "").trim();
  const sec = parseMinSec(raw);
  if (sec <= 0) return alert("분/초 형식으로 입력해 주세요. 예: 8 44");

  setTimer(name, sec, raw);
  document.getElementById('zc-in').value = "";
  document.getElementById('zc-preview').innerText = "--:--:--";
  addLog(`[FORCE] ${name} 강제 업데이트 (${raw})`);
}

/* [ADD] Battle Tracker 버튼 동작용 (누락 함수) */
function btl(type) {
  if (!st.on) return;
  const now = Date.now();
  if (type === 'start') st.battle = { s: now, k: null, est: 0 };
  else if (type === 'kwang') {
    if (!st.battle.s) return;
    st.battle.k = now;
    st.battle.est = Math.floor(((now - st.battle.s) / 1000) * 0.51);
  } else if (type === 'kill') st.battle = { s: null, k: null, est: 0 };
}

/* [REPLACE] setTimer: lastD 초기화 + 알림 플래그 리셋(재설정 시 다시 울리게) */
function setTimer(n, s, raw) {
  pushUndo(`${n} 설정 전`);

  const t = Date.now() + (s * 1000);
  const now = Date.now();
  const d0 = Math.floor((t - now) / 1000);

  // ✅ 알림 누락 방지용 lastD + 플래그 리셋
  const entry = { n, t, m5: false, m1: false, lastD: d0 };

  const i = (st.timers || []).findIndex(x => x.n === n);
  if (i > -1) st.timers[i] = entry;
  else st.timers.push(entry);

  // recent 갱신
  st.recent = [n, ...st.recent.filter(x => x !== n)].slice(0, 5);

  // 입력값 저장
  if (raw !== "자동") localStorage.setItem(`v29_${st.profile}_in_${n}`, raw);

  saveStore();
  renderFavs();
  addLog(`${n} 예약됨`);
}

/* [REPLACE] loop: 알림 '통과 감지' 적용(누락 방지) */
function loop() {
  if (!st.on) return;
  const now = Date.now();

  // 만료 10분 정리
  st.timers = (st.timers || []).filter(t => (now - t.t) < 600000);

  // ✅ 알림: 통과 감지(prev > 300 && d <= 300)
  st.timers.forEach(tm => {
    const d = Math.floor((tm.t - now) / 1000);
    const prev = (typeof tm.lastD === 'number') ? tm.lastD : d;

    if (!tm.m5 && prev > 300 && d <= 300) { triggerAlert(tm.n, "5분 전"); tm.m5 = true; }
    if (!tm.m1 && prev >  60 && d <=  60) { triggerAlert(tm.n, "1분 전"); tm.m1 = true; }

    tm.lastD = d;
  });

  const list = [...st.timers].sort((a, b) => a.t - b.t);
  const upcoming = list.filter(t => t.t > now);
  const next = upcoming.length ? upcoming[0] : null;

  document.getElementById('d-name').innerText = next ? next.n : "No Active Mission";
  document.getElementById('d-timer').innerText = next ? formatTimer(next.t - now) : "00:00:00";
  document.getElementById('d-meta').innerText = next
    ? `${new Date(next.t).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:false})} (${BOSS_WORLD_MAP[next.n]})`
    : "-";

  // 임박(5분 이내) 강조
  document.getElementById('hero-card').className =
    (next && (next.t - now < 300000)) ? 'card hero-timer imminent' : 'card hero-timer';

  // 스케줄러 젠 시간 셀 업데이트
  st.timers.forEach(tm => {
    const el = document.getElementById(`zen-${tm.n}`);
    if (el) el.innerText = new Date(tm.t).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', hour12:false});
  });

  // Top3 미리보기
  document.getElementById('top3-list').innerHTML =
    upcoming.slice(0, 3).map((t, i) => `
      <div style="display:flex; justify-content:space-between; padding:8px 0; border-bottom:1px solid #eee;">
        <span><b>${i+1}.</b> ${t.n}</span>
        <span style="color:var(--primary); font-family:Orbitron; font-weight:700;">
          ${formatTimer(t.t - now).substring(3)}
        </span>
      </div>
    `).join('') || '<div style="color:#aaa; text-align:center;">리젠 예정 보스 없음</div>';

  // 배틀 엔진
  if (st.battle.s && !st.battle.k) document.getElementById('b-elap').innerText = formatSimple((now - st.battle.s) / 1000);
  if (st.battle.k) {
    const rem = st.battle.est - Math.floor((now - st.battle.k) / 1000);
    document.getElementById('b-timer').innerText = (rem >= 0 ? "" : "+") + formatSimple(Math.abs(rem));
  }

  drawPIP(upcoming);
}

/* [REPLACE] renderSched: 월드 배너 접기 클릭 버그 수정 + World Clear 클릭 전파 차단 */
function renderSched() {
  const c = document.getElementById('sched-cont'); 
  let h = '';

  bosses.forEach(g => {
    const folded = st.foldState[g.w] === true;

    h += `
      <div class="world-section ${folded ? 'is-folded' : ''}" data-world="${g.w}">
        <div class="world-banner" style="border-left-color:${g.c}" onclick="toggleFold('${g.w}')">
          <span>${folded ? '▶' : '▼'} ${g.w}</span>
          <button class="btn-sub" style="height:28px; font-size:10px;"
            onclick="event.stopPropagation(); clearWorldTimers('${g.w}')">World Clear</button>
        </div>
        <div class="world-content">
    `;

    g.b.forEach(b => {
      // ✅ 입력값: v29가 없으면 v28도 fallback (운영 편의)
      const v29 = localStorage.getItem(`v29_${st.profile}_in_${b.n}`);
      const sv = (v29 !== null && v29 !== undefined) ? v29 : (localStorage.getItem(`v28_in_${b.n}`) || '');

      const isFav = st.favs.includes(b.n);
      h += `
        <div class="boss-row" data-name="${b.n}">
          <div class="fav-star ${isFav ? 'on' : ''}" style="cursor:pointer; font-size:18px; color:${isFav ? '#f1c40f' : '#ccc'};"
            onclick="toggleFav('${b.n}')">★</div>

          <div style="font-weight:700;">${b.n}</div>

          <div>
            <input type="text" class="v-in" data-name="${b.n}" value="${sv}" placeholder="분/초, hh:mm:ss"
              onkeydown="if(event.key==='Enter') handleEnterNav(this)">
          </div>

          <div id="zen-${b.n}" class="zen-txt">--:--</div>

          <button class="btn-main" style="height:32px; font-size:11px;" onclick="setTimer('${b.n}', ${b.r*60}, '자동')">Killed</button>

          <button class="btn-sub" style="height:32px; width:32px; padding:0; color:var(--danger);" onclick="delTimer('${b.n}')">×</button>
        </div>
      `;
    });

    h += `</div></div>`;
  });

  c.innerHTML = h;
  applyFilters();
}

/* [REPLACE] parseSmart: 한글/다양한 입력 지원(운영 입력 호환성 ↑) */
function parseSmart(s) {
  if (!s) return 0;
  s = String(s).trim();

  // 한글: 1시간 2분 3초 / 8분 44초 / 8분
  let m = s.match(/(\d+)\s*시간\s*(\d+)\s*분(?:\s*(\d+)\s*초?)?/);
  if (m) return (+m[1]) * 3600 + (+m[2]) * 60 + (m[3] ? +m[3] : 0);

  m = s.match(/(\d+)\s*분\s*(\d+)\s*초/);
  if (m) return (+m[1]) * 60 + (+m[2]);

  m = s.match(/(\d+)\s*분/);
  if (m) return (+m[1]) * 60;

  // HH:MM:SS / MM:SS / "8 44"
  const parts = s.split(/[:\s]+/).filter(Boolean).map(Number);
  if (parts.some(v => Number.isNaN(v))) return 0;

  if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
  if (parts.length === 2) return parts[0] * 60 + parts[1];
  if (parts.length === 1) return parts[0] * 60;
  return 0;
}
